import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import "core-js/modules/es.array.concat.js";
import "core-js/modules/es.string.pad-start.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.regexp.to-string.js";
import "core-js/modules/es.regexp.exec.js";
import "core-js/modules/es.string.split.js";

var KissDate = /*#__PURE__*/function () {
  function KissDate(date, timezone) {
    _classCallCheck(this, KissDate);

    this.dateArr = void 0;
    var kissDateTimezone = typeof timezone === 'string' ? KissDate.getTimezone(timezone) : timezone !== null && timezone !== void 0 ? timezone : null;

    if (typeof date === 'number') {
      this.dateArr = [date, kissDateTimezone !== null && kissDateTimezone !== void 0 ? kissDateTimezone : -new Date().getTimezoneOffset() * Time.Minute];
    } else if (Array.isArray(date)) {
      this.dateArr = [date[0], kissDateTimezone !== null && kissDateTimezone !== void 0 ? kissDateTimezone : date[1]];
    } else if (date instanceof Date) {
      this.dateArr = [Math.floor(date.getTime() * Time.Millisecond), kissDateTimezone !== null && kissDateTimezone !== void 0 ? kissDateTimezone : -date.getTimezoneOffset() * Time.Minute];
    } else if (date instanceof KissDate) {
      this.dateArr = date.dateArr;
    } else {
      var jsDate = new Date();
      this.dateArr = [Math.floor(jsDate.getTime() * Time.Millisecond), kissDateTimezone !== null && kissDateTimezone !== void 0 ? kissDateTimezone : -jsDate.getTimezoneOffset() * Time.Minute];
    }
  }

  _createClass(KissDate, [{
    key: "jsDate",
    get: function get() {
      return new Date(this.dateArr[0] / Time.Millisecond);
    }
  }, {
    key: "localShiftedJsDate",
    get: function get() {
      return new Date((this.dateArr[0] + this.timezone) / Time.Millisecond);
    }
  }, {
    key: "changeTimezone",
    value: function changeTimezone(timezone) {
      var adjustTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var kissDateTimezone = typeof timezone === 'string' ? KissDate.getTimezone(timezone) : timezone !== null && timezone !== void 0 ? timezone : null;

      if (!adjustTime) {
        this.dateArr[0] = this.dateArr[0] + this.timezone - kissDateTimezone;
      }

      this.dateArr[1] = kissDateTimezone;
      return this;
    }
  }, {
    key: "timezone",
    get: function get() {
      return this.dateArr[1];
    }
  }, {
    key: "timezoneStr",
    get: function get() {
      var timezoneAbs = Math.abs(this.timezone);
      var hours = Math.floor(timezoneAbs / Time.Hour);
      var minutes = Math.floor(timezoneAbs / Time.Minute % Time.Minute);
      return "".concat(this.timezone < 0 ? '-' : '+').concat(hours.toString().padStart(2, '0'), ":").concat(minutes.toString().padStart(2, '0'));
    }
  }], [{
    key: "getTimezone",
    value: function getTimezone(timezone) {
      if (typeof timezone === 'number') return timezone;
      var timezoneArr = timezone.split(':');
      var timezoneStr = timezoneArr.length > 1 ? timezoneArr[0] + timezoneArr[1] : timezoneArr[0];
      if (timezoneStr.length < 5) timezoneStr = "+".concat(timezoneStr);

      if (timezoneStr[0] !== '+' && timezoneStr[0] !== '-' || timezoneStr.length < 5) {
        throw new Error("".concat(timezone, " is an invalid timezone string"));
      }

      var sign = timezoneStr[0] === '-' ? -1 : 1;
      var hours = parseInt(timezoneStr.substr(1, 2), 10) * Time.Minute;
      var minutes = parseInt(timezoneStr.substr(3, 2), 10) * Time.Minute;
      return (hours * Time.Minute + minutes) * sign;
    }
  }]);

  return KissDate;
}();

export { KissDate as default };
export var Time;

(function (Time) {
  Time[Time["Second"] = 1] = "Second";
  Time[Time["Minute"] = Time.Second * 60] = "Minute";
  Time[Time["Hour"] = Time.Minute * 60] = "Hour";
  Time[Time["Day"] = Time.Hour * 24] = "Day";
  Time[Time["Millisecond"] = 0.001] = "Millisecond";
})(Time || (Time = {}));
//# sourceMappingURL=index.js.map