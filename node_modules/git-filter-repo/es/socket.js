import _newArrowCheck from "@babel/runtime/helpers/newArrowCheck";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.regexp.exec.js";
import "core-js/modules/es.string.match.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.promise.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/es.array.map.js";
import "core-js/modules/es.object.entries.js";
import "core-js/modules/es.object.keys.js";
import "core-js/modules/es.array.join.js";
import "core-js/modules/es.regexp.to-string.js";

/**
 * Copyright 2021 Silicon Hills LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import path from 'path';
import { createServer } from 'net';
import { v4 as uuidv4 } from 'uuid';
import os from 'os';
var tmpPath = os.tmpdir();

var Socket = /*#__PURE__*/function () {
  function Socket() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'captain_hook';
    var commands = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Socket);

    this.name = name;
    this.commands = commands;
    this.path = void 0;
    this.server = void 0;
    this.chunks = {};
    this.path = path.resolve(tmpPath, "".concat(this.name, ".sock"));
  }

  _createClass(Socket, [{
    key: "handleCommand",
    value: function () {
      var _handleCommand = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(commandName, data) {
        var command, result;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                command = this.commands[commandName];
                result = command;

                if (!(typeof command === 'function')) {
                  _context.next = 6;
                  break;
                }

                _context.next = 5;
                return command.apply(void 0, _toConsumableArray(Array.isArray(data) ? data : [data]));

              case 5:
                result = _context.sent;

              case 6:
                if (!(typeof result === 'undefined')) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", null);

              case 8:
                return _context.abrupt("return", result);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function handleCommand(_x, _x2) {
        return _handleCommand.apply(this, arguments);
      }

      return handleCommand;
    }()
  }, {
    key: "handleData",
    value: function () {
      var _handleData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(chunk, client) {
        var _this = this;

        var chunks, data, err, results, resultsKeys;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                chunks = this.chunks[client.id];

                if (!chunks) {
                  chunks = [];
                  this.chunks[client.id] = chunks;
                }

                if (!chunk.match(/\r\n$/)) {
                  _context3.next = 17;
                  break;
                }

                chunks.push(chunk.slice(0, chunk.length - 2));
                data = this.parseChunks(chunks);

                if (!(typeof data === 'string')) {
                  _context3.next = 9;
                  break;
                }

                err = new Error("'".concat(data, "' is invalid"));
                client.write("".concat(JSON.stringify({
                  err: {
                    message: err.message
                  }
                }), "\r\n"));
                throw err;

              case 9:
                _context3.next = 11;
                return Promise.all(Object.entries(data).map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {
                    var _ref3, command, data;

                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _ref3 = _slicedToArray(_ref, 2), command = _ref3[0], data = _ref3[1];
                            _context2.t0 = command;
                            _context2.next = 4;
                            return _this.handleCommand(command, data);

                          case 4:
                            _context2.t1 = _context2.sent;
                            return _context2.abrupt("return", [_context2.t0, _context2.t1]);

                          case 6:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x5) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 11:
                results = _context3.sent.reduce(function (result, _ref4) {
                  _newArrowCheck(this, _this);

                  var _ref5 = _slicedToArray(_ref4, 2),
                      command = _ref5[0],
                      data = _ref5[1];

                  result[command] = data;
                  return result;
                }.bind(this), {});
                resultsKeys = Object.keys(results);
                if (resultsKeys.length === 1) results = results[resultsKeys[0]];
                client.write("".concat(JSON.stringify(results), "\r\n"));
                _context3.next = 18;
                break;

              case 17:
                chunks.push(chunk);

              case 18:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function handleData(_x3, _x4) {
        return _handleData.apply(this, arguments);
      }

      return handleData;
    }()
  }, {
    key: "parseChunks",
    value: function parseChunks(chunks) {
      var data = Array.isArray(chunks) ? chunks.join('') : chunks.toString();

      try {
        return JSON.parse(data);
      } catch (err) {
        return data;
      }
    }
  }, {
    key: "handleCleanup",
    value: function handleCleanup() {
      this.close();
    }
  }, {
    key: "connect",
    value: function () {
      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this2 = this;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                process.on('exit', this.handleCleanup.bind(this));
                process.on('SIGINT', this.handleCleanup.bind(this));
                process.on('SIGUSR1', this.handleCleanup.bind(this));
                process.on('SIGUSR2', this.handleCleanup.bind(this));
                process.on('uncaughtException', this.handleCleanup.bind(this));
                _context4.next = 7;
                return new Promise(function (resolve, reject) {
                  var _this3 = this;

                  _newArrowCheck(this, _this2);

                  try {
                    var server = createServer(function (socket) {
                      var _this4 = this;

                      _newArrowCheck(this, _this3);

                      var client = socket;
                      client.id = uuidv4();
                      client.setEncoding('utf8');
                      client.on('data', function (chunk) {
                        _newArrowCheck(this, _this4);

                        return this.handleData(chunk, client);
                      }.bind(this));
                    }.bind(this));
                    server.on('listening', function () {
                      _newArrowCheck(this, _this3);

                      return resolve(server);
                    }.bind(this));
                    server.listen(this.path);
                  } catch (err) {
                    reject(err);
                  }
                }.bind(this));

              case 7:
                this.server = _context4.sent;

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function connect() {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var _this5 = this;

        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this.server) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return");

              case 2:
                _context5.next = 4;
                return new Promise(function (resolve, reject) {
                  var _this6 = this;

                  _newArrowCheck(this, _this5);

                  if (!this.server) return resolve(null);

                  try {
                    process.removeListener('exit', this.handleCleanup.bind(this));
                    process.removeListener('SIGINT', this.handleCleanup.bind(this));
                    process.removeListener('SIGUSR1', this.handleCleanup.bind(this));
                    process.removeListener('SIGUSR2', this.handleCleanup.bind(this));
                    process.removeListener('uncaughtException', this.handleCleanup.bind(this));
                    return this.server.close(function () {
                      _newArrowCheck(this, _this6);

                      return resolve(null);
                    }.bind(this));
                  } catch (err) {
                    return reject(err);
                  }
                }.bind(this));

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }]);

  return Socket;
}();

export { Socket as default };
//# sourceMappingURL=socket.js.map